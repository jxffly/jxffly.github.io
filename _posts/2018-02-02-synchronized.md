---
layout: post
title:  "java的并发控制的实现"
date: 2018-02-01 00:00:00
tags: concurrent java 并发 多线程
---
# java的并发

## 1.多线程的含义

​	逻辑语义的正确，如果A和B没有任何关系，那么A和B同时在各个线程老死不相往来，这也叫并发。

​	但是我们经常一说到多线程基本就是指对共享资源的正确竞争，这也就是我们经常说的，**并发控制**，使用一定的语义手段，来确保对共享资源的正确的访问和操作。什么叫正确性，程序语义上面的正确性，而不是多种并发场景的多变性。比如同时向商家付款，A线程如果在B前面付钱，B在后面，那么B一定是在A支付之后的余额上面加钱，而不是随机去抢占，这就涉及到对共享资源的正确访问。

​	并行（**parrell**）与并发(**concurrent**)是一回事吗？

​	no，并行是真正意义的多个线程一起执行,CPU级别需要支持多个线程同时可以执行，并发并不一定是需要多核CPU的支持，他指的是多个线程能够被CPU轮流切换着执行，并发也可能是并行的一种，前者和后者仅仅是在CPU支持模式上面不同，并不一定是要有确切的分别。并发关注的是应用级别，而并发强调的是CPU的能力。

​	实现并发控制的手段有很多种，java当中一般有 Lock，synchronized以及CAS，当然还有JUC里面的各种并发控制包，但是其底层都是使用AQS来实现并发控制的，是一种无锁同步的实现。

## 2.synchronized

### 2.1 synchronized关键字

​		 synchronized关键字很早就加入到jdk当中，它可以修饰方法（静态和实例方法），代码片段，这个是如何实现的呢？我们需要明确多线程到底是怎么进行互斥访问的。

### 2.2 Monitor Object 模式

​	Monitor 其实是一种同步工具，或者说是同步机制，它通常被描述成一个对象，主要特点是：

1. **同步**。对象内的所有方法都互斥的执行。好比一个 Monitor 只有一个运行许可，任一个线程进入任何一个方法都需要获得这个许可，离开时把许可归还。
2. **协作**。通常提供signal机制：允许正持有许可的线程暂时放弃许可，等待某个监视条件成真，条件成立后，当前线程可以通知正在等待这个条件的线程，让它可以重新获得运行许可。

#### 2.2.1 结构

在 Monitor Object 模式中，主要有四种类型参与者：
**监视者对象 Monitor Object**
负责公共的接口方法，这些公共的接口方法会在多线程的环境下被调用执行。
**同步方法**
这些方法是监视者对象所定义。为了防止竞争条件，无论是否有多个线程并发调用同步方法，还是监视者对象还用多个同步方法，在任一事件内只有一个同步方法能够执行。
**监控锁 Monitor Lock**
每一个监视者对象都会拥有一把监视锁。
**监控条件 Monitor Condition**
同步方法使用监视锁和监视条件来决定方法是否需要阻塞或重新执行。

#### 2.2.2 执行序列

在 Monitor Object 模式中，参与者之间将发生如下协作过程：

1. 同步方法的调用和串行化。当某线程调用监视者对象的同步方法时，必须首先获得它的监视锁。只要监视者对象有其他同步方法正在执行，获取操作便不会成功，该线程将处于**阻塞（BLOCKED）**状态。当线程获得监控锁后，执行方法实现服务，一旦同步方法完成执行，监视锁自动释放。
2. 同步方法线程挂起。如果调用同步方法的线程必须被阻塞或是其他原因不能立刻进行，它能够在一个监视条件上等待，这将导致该客户线程暂时释放监视锁，并**挂起（WAITING / TIMED_WAITING）**在监视条件上。
3. 监视条件通知。线程能够通知一个监视条件，目的是为了让一个前期使自己挂起在一个监视条件上的同步方法线程恢复运行。
4. 同步方法线程回复。一旦早先挂起在某监视条件上的同步方法线程获取通知，它将继续在最初的等待监视条件的点上执行，执行的条件是唤醒后抢占到监视锁。（java基于抢占式的原因）

下图描述了监视者对象的动态特性：

![img1](/image/concurrent.jpg)

### 3.Java 中的Monitor

​	实质上，Java 的 Object 类本身就是监视者对象，Java 对于 Monitor Object 模式做了内建的支持。

- Object 类本身就是监视者对象

- 每个 Object 类都带了一把看不见的锁，通常叫 内部锁/Monitor 锁/Instrinsic Lock, 这把锁就是 监控锁

- synchronized 关键字修饰方法和代码块就是 同步方法，也是synchronized关键字生效的原因

- wait()/notify()/notifyAll() 方法构成监控条件(Monitor Condition)

下图描述了 Java Monitor 的工作机理：

![Java Monitor工作机理](/image/monitor.jpg)

1. 
   线程进入同步方法中，并不是立马获取Monitor锁：

2. 为了继续执行临界区代码，线程必须获取 Monitor 锁。如果获取锁成功，将成为该监视者对象的拥有者。任一时刻内，监视者对象只属于一个活动线程（The Owner）
3. 拥有监视者对象的线程可以调用 wait() 进入等待集合（Wait Set），同时释放监视锁，进入等待状态。
4. 其他线程调用 notify() / notifyAll() 接口唤醒等待集合中的线程，这些等待的线程**需要重新获取监视锁**后才能执行 wait() 之后的代码。
5. 同步方法执行完毕了，线程退出临界区，并释放监视锁。



可以看一个列子：

```java
 public static synchronized void test1() {
        log.info("test1");
        try {
            Thread.sleep(3000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }


    public static void test2() {
        synchronized (SynchronizedTest.class) {
            log.info("test2");
            try {
                Thread.sleep(3000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    }
```

输出内容是：

2018-02-01 09:22:17.473 [Thread-0] INFO   com.concurrent.monitor.SynchronizedTest.test1 - test1
2018-02-01 09:22:20.483 [Thread-1] INFO   com.concurrent.monitor.SynchronizedTest.test2 - test2

我们从下面可以看到，在SynchronizedTest当中，synchronized和synchronized(SynchronizedTest.class)竞争的是同一把锁，他们其实质是使用的一个monitor，因此他们需要相互等待，发现两者的间隔是3.01秒，多的10毫秒应该是线程切换的时间，感觉线程切换真的很耗时，已经到达毫秒级别了。

另外，notify和notifyAll只会去唤醒处于wait队列里面的线程。

#### 3.1.关于 wait / notify / notifyAll

##### 条件队列

条件队列（图2 中的 Wait Set）存储的是"处于等待状态的线程"，这些线程在等待某种特定的条件变成真。正如每个Java对象都可以作为一个锁，每个对象同样可以作为一个条件队列，这个对象的wait /notify / notifyAll就构成了内部条件队列的API。对象的监控锁与条件队列是相互关联的。要调用条件队列的任何一个方法，必须先持有该对对象上的锁，一个推论就是“wait / notify  方法只能出现在相应的同步块中”。如果不在同步方法或同步块中，运行时会报IllegalMonitorStateException。



```
void xxxMethod() throws InterruptedException{  
    synchronized(lock){  
        while(!conditionPredition)  
            lock.wait();  
        doSomething();  
    }  
}

```

1. wait 必须在 synchronized 方法或代码块中

2. 用 while 而不是 if 判断监视条件，因为当线程被唤醒的时候，监视条件可能根本没有被满足。如当前线程调用的是 notifyAll

3. lock可以是this

4. notify 是从条件队列从随机选择一个线程来唤醒，而 notifyAll 是唤醒条件队列中的所有线程。

   ​

   **只有同时满足下列两个条件时，才使用 notify 而不是 notifyAll：**

5. 所有的等待线程类型相同：只有一个监视条件与条件队列相关，并且每个线程从 wait 返回后将执行相同的操作。
   单进单出：条件变量上的每次通知，最多只能唤醒一个线程来执行。

## 4.java的synchronized的优化

#### 4.1 java的线程的线程状态

![java的线程状态](/image/thread-state.png)

**其中以下状态的转移需要关注下：**

1. New -> RUNNABLE
   线程实例调用 start 方法即可进入可运行状体。
2. 如果正在执行的线程运行到 yield 方法，则让出 CPU 时间片，但状态还是 RUNNABLE。
   RUNNABLE -> BLOCKED
   通常调用 synchronized 方法，或者尝试进入 synchronized 程序时，又没抢占到 Object 的 Monitor 锁时，会产生这种状态迁移。
3. RUNNABLE -> WAITING
   线程调用 Object.wait() / LockSupport.park() / Thread.join() 方法。
   其中 join 方法是 synchronized 方法，内部调用当前线程对象的 wait 方法。
4. RUNNABLE -> TIMED_WAITING
   情况和 RUNNABLE -> WAITING 类似，但是增加了 Thread.sleep 情况，调用 sleep 时 不会释放 当前线程抢占到的 Monitor 锁，所以当 sleep 结束后，依旧进入 RUNNABLE 状态。
5. WAITING -> RUNNABLE
   其他线程调用 Object.notify() / Object.notifyAll() 时，某等待线程被唤醒，同时抢到等待对象的 Monitor锁。
6. WAITING -> BLOCKED
   其他线程调用 Object.notify() / Object.notifyAll() 时，某等待线程被唤醒，同时没有抢到等待对象的 Monitor锁，只能被阻塞等待其他线程释放锁。

#### 4.2 synchronized底层优化

##### 4.2.1 重量级锁

​	上个章节中向大家介绍了Synchronized的用法及其实现的原理。现在我们应该知道，Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。

##### 4.2.2 轻量级锁

**二、轻量级锁 **

　　锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK 1.6中默认是开启偏向锁和轻量级锁的，我们也可以通过-XX:-UseBiasedLocking来禁用偏向锁。锁的状态保存在对象的头文件中，以32位的JDK为例：

　　“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。
![轻量级锁对象头](/image/lock.png)


1、**轻量级锁的加锁过程**

　　（1）在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。这时候线程堆栈与对象头的状态如下图。

　　（2）拷贝对象头中的Mark Word复制到锁记录中。

　　（3）拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤（4），否则执行步骤（5）。

　　（4）如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如下图。

　　（5）如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。

![轻量级锁加锁](/image/light-lock.png)

​						轻量级锁加锁的过程

![轻量级锁解锁](/image/light-lock2.png)

​						轻量级锁解锁的过程


**2、轻量级锁的解锁过程：**

　　（1）通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。

　　（2）如果替换成功，整个同步过程就完成了。

　　（3）如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。

**4.2.2、偏向锁**

　　引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。

##### **1、偏向锁获取过程：**

　　（1）访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。

　　（2）如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。

　　（3）如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。

　　（4）如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。

　　（5）执行同步代码。

##### **2、偏向锁的释放：**

**　　**偏向锁的撤销在上述第四步骤中有提到**。**偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。

###### **3、重量级锁、轻量级锁和偏向锁之间转换**
![锁的膨胀和转换](/image/lock-processor.png)


**4.2.3、其他优化 **

1、**适应性自旋（Adaptive Spinning）：**从轻量级锁获取的流程中我们知道**，**当线程在获取轻量级锁的过程中执行CAS操作失败时，是要通过自旋来获取重量级锁的。问题在于，自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。解决这个问题最简单的办法就是指定自旋的次数，例如让其循环10次，如果还没获取到锁就进入阻塞状态。但是JDK采用了更聪明的方式——适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。

**2、锁粗化（Lock Coarsening）：**锁粗化的概念应该比较好理解，就是将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁。举个例子：

```java
package com.paddx.test.string;

public class StringBufferTest {
    StringBuffer stringBuffer = new StringBuffer();

    public void append(){
        stringBuffer.append("a");
        stringBuffer.append("b");
        stringBuffer.append("c");
    }
}
```

　这里每次调用stringBuffer.append方法都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。

**3、锁消除（Lock Elimination）：**锁消除即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。看下面这段程序：

```java
 public void append(String str1, String str2) {
        StringBuffer sb = new StringBuffer();
        sb.append(str1).append(str2);
    }
```

虽然StringBuffer的append是一个同步方法，但是这段程序中的StringBuffer属于一个局部变量，并且不会从该方法中逃逸出去，所以其实这过程是线程安全的，可以将锁消除。

### **5.总结 **

　　本节内容重点介绍了：

1. java的锁实现的模型，使用监视器来实现锁，重量级锁底层真正使用的是cup的 mutex lock来实现的。
2. JDK中采用轻量级锁和偏向锁等对Synchronized的优化，但是这两种锁也不是完全没缺点的，比如竞争比较激烈的时候，不但无法提升效率，反而会降低效率，因为多了一个锁升级的过程，这个时候就需要通过-XX:-UseBiasedLocking来禁用偏向锁。下面是这几种锁的对比：

| 锁    | 优点                                | 缺点                       | 适用场景               |
| ---- | --------------------------------- | ------------------------ | ------------------ |
| 偏向锁  | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 | 适用于只有一个线程访问同步块场景。  |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度。             | 如果始终得不到锁竞争的线程使用自旋会消耗CPU。 | 追求响应时间。同步块执行速度非常快。 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU。                | 线程阻塞，响应时间缓慢。             | 追求吞吐量。同步块执行速度较长。   |